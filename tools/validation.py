import random
import sys
import time
import threading
import os
import argparse
import signal

from stress import Validation, LatticeAgreementValidation, startProcesses, positive_int


def main(parser_results, testConfig):
    cmd = parser_results.command
    runscript = parser_results.runscript
    logsDir = parser_results.logsDir
    processes = parser_results.processes

    if not os.path.isdir(logsDir):
        raise ValueError("Directory `{}` does not exist".format(logsDir))

    if cmd == "perfect":
        validation = Validation(processes, parser_results.messages)
        hostsFile, configFile = validation.generatePerfectLinksConfig(logsDir)
        configFiles = [configFile]
    elif cmd == "fifo":
        validation = Validation(processes, parser_results.messages)
        hostsFile, configFile = validation.generateFifoConfig(logsDir)
        configFiles = [configFile]
    elif cmd == "agreement":
        proposals = parser_results.proposals
        pmv = parser_results.proposal_max_values
        pdv = parser_results.proposals_distinct_values

        if pmv > pdv:
            print(
                "The distinct proposal values must at least as many as the maximum values per proposal"
            )
            sys.exit(1)

        validation = LatticeAgreementValidation(processes, proposals, pmv, pdv)
        hostsFile, configFiles = validation.generate(logsDir)
    else:
        raise ValueError("Unrecognized command")

    try:
        # Start the processes and get their PIDs
        procs = startProcesses(processes, runscript, hostsFile, configFiles, logsDir)

        for (logicalPID, procHandle) in procs:
            print(
                "Process with logicalPID {} has PID {}".format(
                    logicalPID, procHandle.pid
                )
            )

        input("Press `Enter` when all processes have finished processing messages.")
        
        # Stop all processes
        mutex = threading.Lock()
        for (logicalPID, handle) in procs:
            with mutex:
                handle.send_signal(signal.SIGTERM)

        def waitForProcess(logicalPID, procHandle, mutex):
            procHandle.wait()

            with mutex:
                print(
                    "Process {} exited with {}".format(
                        logicalPID, procHandle.returncode
                    )
                )

        # Monitor which processes have exited
        monitors = [
            threading.Thread(
                target=waitForProcess, args=(logicalPID, procHandle, mutex)
            )
            for (logicalPID, procHandle) in procs
        ]
        [p.start() for p in monitors]
        [p.join() for p in monitors]

    finally:
        if procs is not None:
            for _, p in procs:
                p.kill()


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    sub_parsers = parser.add_subparsers(dest="command", help="stress a given milestone")
    sub_parsers.required = True
    parser_perfect = sub_parsers.add_parser("perfect", help="stress perfect links")
    parser_fifo = sub_parsers.add_parser("fifo", help="stress fifo broadcast")
    parser_agreement = sub_parsers.add_parser(
        "agreement", help="stress lattice agreement"
    )

    for subparser in [parser_perfect, parser_fifo, parser_agreement]:
        subparser.add_argument(
            "-r",
            "--runscript",
            required=True,
            dest="runscript",
            help="Path to run.sh",
        )

        subparser.add_argument(
            "-l",
            "--logs",
            required=True,
            dest="logsDir",
            help="Directory to store stdout, stderr and outputs generated by the processes",
        )

        subparser.add_argument(
            "-p",
            "--processes",
            required=True,
            type=positive_int,
            dest="processes",
            help="Number of processes that broadcast",
        )

    for subparser in [parser_perfect, parser_fifo]:
        subparser.add_argument(
            "-m",
            "--messages",
            required=True,
            type=positive_int,
            dest="messages",
            help="Maximum number (because it can crash) of messages that each process can broadcast",
        )

    parser_agreement.add_argument(
        "-n",
        "--proposals",
        required=True,
        type=positive_int,
        dest="proposals",
        help="Maximum number (because it can crash) of proposal that each process can make",
    )

    parser_agreement.add_argument(
        "-v",
        "--proposal-values",
        required=True,
        type=positive_int,
        dest="proposal_max_values",
        help="Maximum size of the proposal set that each process proposes",
    )

    parser_agreement.add_argument(
        "-d",
        "--distinct-values",
        required=True,
        type=positive_int,
        dest="proposals_distinct_values",
        help="The number of distinct values among all proposals",
    )

    results = parser.parse_args()

    testConfig = {
        "concurrency": 8,  # How many threads are interferring with the running processes
        "attempts": 8,  # How many interferring attempts each threads does
        "attemptsDistribution": {  # Probability with which an interferring thread will
            "STOP": 0.48,  # select an interferring action (make sure they add up to 1)
            "CONT": 0.48,
            "TERM": 0.04,
        },
    }

    main(results, testConfig)
